<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ggluo.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ggluo.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-31T07:51:00+00:00</updated><id>https://ggluo.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Learn C++ 5: Inline Function</title><link href="https://ggluo.github.io/2023/03/11/learn-c-5.html" rel="alternate" type="text/html" title="Learn C++ 5: Inline Function"/><published>2023-03-11T07:28:00+00:00</published><updated>2023-03-11T07:28:00+00:00</updated><id>https://ggluo.github.io/2023/03/11/learn-c-5</id><content type="html" xml:base="https://ggluo.github.io/2023/03/11/learn-c-5.html"><![CDATA[<p>I got the error message below when compiling my project. At the beginning, I had no idea what was going on. I only define the function <code class="language-plaintext highlighter-rouge">load_engine</code> once in the header file, and there is no definition elsewhere.</p> <pre><code class="language-log">/usr/bin/ld: CMakeFiles/main.dir/src/trt.cpp.o: in function `load_engine()':
trt.cpp:(.text+0x131): multiple definition of `load_engine()'; 
CMakeFiles/main.dir/src/main.cpp.o:main.cpp:(.text+0x0): first defined here
</code></pre> <p>It looks like this in the header file</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">infer_params</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">weights_file</span><span class="p">;</span> <span class="c1">// currently supports only uff file</span>
    <span class="kt">int</span> <span class="n">batch_size</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">save_engine</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">load_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="nf">load_engine</span><span class="p">(){</span>
<span class="c1">// do something....</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">load_engine</code> was defined with a string in the struct, and then <code class="language-plaintext highlighter-rouge">load_engine</code>was defined with a function. I could change the namings or use <code class="language-plaintext highlighter-rouge">inline</code> when define <code class="language-plaintext highlighter-rouge">load_engine</code> at the second time. As an inline function is a function defined in C++ that is expanded in place at each point in your code where it is called, rather than being called through the usual function call mechanism.</p>]]></content><author><name></name></author><category term="c++"/><summary type="html"><![CDATA[I got the error message below when compiling my project. At the beginning, I had no idea what was going on. I only define the function load_engine once in the header file, and there is no definition elsewhere.]]></summary></entry><entry><title type="html">Learn C++ 4: std::array vs std::vector</title><link href="https://ggluo.github.io/2023/03/09/learn-c-4.html" rel="alternate" type="text/html" title="Learn C++ 4: std::array vs std::vector"/><published>2023-03-09T18:28:00+00:00</published><updated>2023-03-09T18:28:00+00:00</updated><id>https://ggluo.github.io/2023/03/09/learn-c-4</id><content type="html" xml:base="https://ggluo.github.io/2023/03/09/learn-c-4.html"><![CDATA[<p><code class="language-plaintext highlighter-rouge">std::array</code> and <code class="language-plaintext highlighter-rouge">std::vector</code> are both container classes provided by the C++ Standard Library, but they have different characteristics and are used for different purposes:</p> <ol> <li><strong>Size</strong>: <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::array</code></strong>: Has a fixed size determined at compile time, specified by its template parameter. Once created, the size of a <code class="language-plaintext highlighter-rouge">std::array</code> cannot be changed.</li> <li><strong><code class="language-plaintext highlighter-rouge">std::vector</code></strong>: Has a dynamic size that can grow or shrink at runtime. Elements can be added or removed from a <code class="language-plaintext highlighter-rouge">std::vector</code> after it’s created.</li> </ul> </li> <li><strong>Memory Allocation</strong>: <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::array</code></strong>: Typically allocated on the stack. The size of a <code class="language-plaintext highlighter-rouge">std::array</code> must be known at compile time, so its memory is allocated statically.</li> <li><strong><code class="language-plaintext highlighter-rouge">std::vector</code></strong>: Typically allocated on the heap. The memory for a <code class="language-plaintext highlighter-rouge">std::vector</code> is dynamically allocated, allowing it to resize as needed.</li> </ul> </li> <li><strong>Accessing Elements</strong>: <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::array</code></strong>: Supports constant time (O(1)) random access to elements using the <code class="language-plaintext highlighter-rouge">[]</code> operator. It provides efficient access to elements since the array is contiguous in memory.</li> <li><strong><code class="language-plaintext highlighter-rouge">std::vector</code></strong>: Supports constant time (O(1)) random access to elements using the <code class="language-plaintext highlighter-rouge">[]</code> operator. Like <code class="language-plaintext highlighter-rouge">std::array</code>, it provides efficient access to elements due to its contiguous memory layout.</li> </ul> </li> <li><strong>Performance</strong>: <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::array</code></strong>: Typically offers better performance than <code class="language-plaintext highlighter-rouge">std::vector</code> for small, fixed-size collections because of its static memory allocation and lack of dynamic resizing overhead.</li> <li><strong><code class="language-plaintext highlighter-rouge">std::vector</code></strong>: Offers better performance for large collections or when the size of the collection is unknown at compile time, as it can dynamically resize itself to accommodate new elements.</li> </ul> </li> <li><strong>Usage</strong>: <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::array</code></strong>: Useful when the size of the collection is known at compile time and does not change. It’s often used for small, fixed-size collections where the size is known in advance.</li> <li><strong><code class="language-plaintext highlighter-rouge">std::vector</code></strong>: Suitable when the size of the collection can change dynamically at runtime or when the size is not known at compile time. It’s a versatile container that can be resized and is widely used in C++.</li> </ul> </li> </ol> <p>In summary, choose <code class="language-plaintext highlighter-rouge">std::array</code> when you need a fixed-size container with known size at compile time, and choose <code class="language-plaintext highlighter-rouge">std::vector</code> when you need a dynamic-size container or when the size is not known at compile time.</p>]]></content><author><name></name></author><category term="c++"/><summary type="html"><![CDATA[std::array and std::vector are both container classes provided by the C++ Standard Library, but they have different characteristics and are used for different purposes:]]></summary></entry><entry><title type="html">How Bindings Work with I/O in TensorRT</title><link href="https://ggluo.github.io/2023/03/08/bindings-in-tensorrt.html" rel="alternate" type="text/html" title="How Bindings Work with I/O in TensorRT"/><published>2023-03-08T11:31:00+00:00</published><updated>2023-03-08T11:31:00+00:00</updated><id>https://ggluo.github.io/2023/03/08/bindings-in-tensorrt</id><content type="html" xml:base="https://ggluo.github.io/2023/03/08/bindings-in-tensorrt.html"><![CDATA[<p>In TensorRT, a “binding” refers to the association between a tensor in the computational graph (network) and a specific memory buffer that holds the data for that tensor during inference. Bindings are used to specify how input and output tensors of a neural network are mapped to memory buffers where the input data is provided and where the output data is retrieved after inference.</p> <p>Here’s a basic overview of how bindings work in TensorRT from the docs from <a href="https://docs.nvidia.com/deeplearning/tensorrt/api/python_api/infer/Core/Engine.html?highlight=binding#tensorrt.ICudaEngine">TensorRT engine</a> :</p> <ol> <li> <p><strong>Input Bindings</strong>: Input bindings specify where the input data for the neural network will be located during inference. Typically, this involves specifying memory buffers where the input data is stored, such as CPU or GPU memory.</p> </li> <li> <p><strong>Output Bindings</strong>: Output bindings specify where the output data produced by the neural network during inference will be placed. Similar to input bindings, output bindings specify memory buffers where the output data will be stored, such as CPU or GPU memory.</p> </li> <li> <p><strong>Binding Indices</strong>: Each input and output tensor in the network is associated with a unique binding index. These binding indices are used to identify which input or output tensor corresponds to which memory buffer during inference.</p> </li> <li> <p><strong>Binding Shapes</strong>: Along with specifying the memory location for input and output tensors, bindings also specify the shape (dimensions) of each tensor. This ensures that the memory buffers provided for input and output data have the correct size to accommodate the tensors produced by the network.</p> </li> <li> <p><strong>Binding Data Types</strong>: Bindings also specify the data type of each tensor, such as float32, int8, etc. This ensures that the memory buffers provided for input and output data have the correct data type to match the tensors produced by the network.</p> </li> </ol>]]></content><author><name></name></author><category term="c++"/><category term="tensorRT"/><summary type="html"><![CDATA[In TensorRT, a “binding” refers to the association between a tensor in the computational graph (network) and a specific memory buffer that holds the data for that tensor during inference. Bindings are used to specify how input and output tensors of a neural network are mapped to memory buffers where the input data is provided and where the output data is retrieved after inference.]]></summary></entry><entry><title type="html">Learn C++ 3: Disallow C++ class copy and assignment</title><link href="https://ggluo.github.io/2023/03/02/learn-c-3.html" rel="alternate" type="text/html" title="Learn C++ 3: Disallow C++ class copy and assignment"/><published>2023-03-02T12:31:00+00:00</published><updated>2023-03-02T12:31:00+00:00</updated><id>https://ggluo.github.io/2023/03/02/learn-c-3</id><content type="html" xml:base="https://ggluo.github.io/2023/03/02/learn-c-3.html"><![CDATA[<p>I came across the two lines below. At the beginning, I thought they are declaration for a customized destructor. It turned out that I’m wrong after a discussion with my colleague.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">net_infer</span><span class="p">(</span><span class="k">const</span> <span class="n">net_infer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">net_infer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">net_infer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</code></pre></div></div> <h4 id="1-disallow-copy">1. Disallow copy</h4> <p>a. <strong>net_infer</strong>: This is the name of the class.</p> <p>b. <strong>const net_infer&amp;</strong>: This is a reference to a const object of type <strong>net_infer</strong>. It’s the parameter type of the copy constructor.</p> <p>c. <strong>= delete</strong>: This part of the declaration explicitly deletes the copy constructor. It means that attempts to create copies of <strong>net_infer</strong> objects using the copy constructor will result in a compilation error.</p> <h4 id="2-disallow-assignment">2. Disallow assignment</h4> <p>a. <strong>net_infer&amp;</strong>: This specifies the return type of the copy assignment operator. It returns a reference to a net_infer object.</p> <p>b. <strong>operator=</strong>: This is the name of the copy assignment operator.</p> <p>c. <strong>(const net_infer&amp;)</strong>: This specifies the parameter of the copy assignment operator, which is a reference to a const object of type net_infer. This parameter represents the object that is being assigned from.</p> <p>d. <strong>= delete</strong>: This part of the declaration explicitly deletes the copy assignment operator. It means that attempts to assign one net_infer object to another using the copy assignment operator will result in a compilation error.</p> <p>By deleting the copy assignment operator or the copy constructor, the class net_infer effectively disallows assignment operations and copy between its instances. This is useful in cases where copying or assigning instances of the class would lead to undesirable behavior, such as resource leaks or invalid state changes.</p>]]></content><author><name></name></author><category term="c++"/><summary type="html"><![CDATA[I came across the two lines below. At the beginning, I thought they are declaration for a customized destructor. It turned out that I’m wrong after a discussion with my colleague.]]></summary></entry><entry><title type="html">Learn C++ 2: Integrating TensorRT Libraries into CMake Projects</title><link href="https://ggluo.github.io/2023/02/08/learn-c-2.html" rel="alternate" type="text/html" title="Learn C++ 2: Integrating TensorRT Libraries into CMake Projects"/><published>2023-02-08T17:31:00+00:00</published><updated>2023-02-08T17:31:00+00:00</updated><id>https://ggluo.github.io/2023/02/08/learn-c-2</id><content type="html" xml:base="https://ggluo.github.io/2023/02/08/learn-c-2.html"><![CDATA[<p>I downloaded the tar file for <a href="https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html#installing-tar"><code class="language-plaintext highlighter-rouge">TensorRT</code></a> local installation and unpacked it into a local folder. I want to use the dynamic libraries in it such as <code class="language-plaintext highlighter-rouge">libnvinfer.so</code> when compiling my project with CMake. How shoud I configurate it in the CMakeLists.txt?</p> <ol> <li>Locate the directory into which you unpack TensorRT tar file. This directory contains the header files (‘include/*.h’) and libraries (‘lib/*.so’). <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set(TENSORRT_DIR /path/to/tensorrt)
</code></pre></div> </div> </li> <li>Use <code class="language-plaintext highlighter-rouge">find_library</code> command to find (‘*.so’) under directory <code class="language-plaintext highlighter-rouge">lib</code> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find_library(NVINFER_LIB libnvinfer.so PATHS ${TENSORRT_DIR}/lib)
</code></pre></div> </div> </li> <li>Use <code class="language-plaintext highlighter-rouge">include_directories</code> command to include header files (‘*.h’) under directory <code class="language-plaintext highlighter-rouge">include</code> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include_directories(${TENSORRT_DIR}/include)
</code></pre></div> </div> </li> <li>Use <code class="language-plaintext highlighter-rouge">link_libraries</code> command to link the TensorRT libraries to your target <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>link_libraries(${NVINFER_LIB} ${NVONNXPARSER_LIB} ${CUDA_LIBRARIES})
</code></pre></div> </div> </li> </ol> <p>The code block below is the complete CMake file.</p> <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.11<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>trt_examples<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 14<span class="p">)</span>

<span class="c1"># CUDA</span>
<span class="nb">find_package</span><span class="p">(</span>CUDA REQUIRED<span class="p">)</span>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">CUDA_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">message</span><span class="p">(</span><span class="s2">"CUDA_TOOLKIT_ROOT_DIR = </span><span class="si">${</span><span class="nv">CUDA_TOOLKIT_ROOT_DIR</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">message</span><span class="p">(</span><span class="s2">"CUDA_INCLUDE_DIRS = </span><span class="si">${</span><span class="nv">CUDA_INCLUDE_DIRS</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">message</span><span class="p">(</span><span class="s2">"CUDA_LIBRARIES = </span><span class="si">${</span><span class="nv">CUDA_LIBRARIES</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># TensorRT</span>
<span class="nb">set</span><span class="p">(</span>TENSORRT_DIR  <span class="s2">"/home/gluo/local_lib/TensorRT-8.6.1.6/"</span><span class="p">)</span>
<span class="nb">find_library</span><span class="p">(</span>NVINFER_LIB libnvinfer.so PATHS <span class="si">${</span><span class="nv">TENSORRT_DIR</span><span class="si">}</span>/lib<span class="p">)</span>
<span class="nb">find_library</span><span class="p">(</span>NVONNXPARSER_LIB libnvonnxparser.so PATHS <span class="si">${</span><span class="nv">TENSORRT_DIR</span><span class="si">}</span>/lib<span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">TENSORRT_DIR</span><span class="si">}</span>/include<span class="p">)</span>
<span class="nb">link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">NVINFER_LIB</span><span class="si">}</span> <span class="si">${</span><span class="nv">NVONNXPARSER_LIB</span><span class="si">}</span> <span class="si">${</span><span class="nv">CUDA_LIBRARIES</span><span class="si">}</span><span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>example1 example1.cpp<span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="c++"/><category term="tensorRT"/><summary type="html"><![CDATA[I downloaded the tar file for TensorRT local installation and unpacked it into a local folder. I want to use the dynamic libraries in it such as libnvinfer.so when compiling my project with CMake. How shoud I configurate it in the CMakeLists.txt?]]></summary></entry><entry><title type="html">Learn C++ 1: Initializing Objects with Functions</title><link href="https://ggluo.github.io/2023/02/07/learn-c-1.html" rel="alternate" type="text/html" title="Learn C++ 1: Initializing Objects with Functions"/><published>2023-02-07T12:55:00+00:00</published><updated>2023-02-07T12:55:00+00:00</updated><id>https://ggluo.github.io/2023/02/07/learn-c-1</id><content type="html" xml:base="https://ggluo.github.io/2023/02/07/learn-c-1.html"><![CDATA[<p>As a newbie to C++, I came across many challenges when working on a project with this versatile language. Learn by doing, these blogs (Learn C++) are the record of practical examples I collected.</p> <p>I was confused by the following line, when reading the implementation of <a href="https://github.com/NVIDIA/TensorRT/blob/c0c633cc629cc0705f0f69359f531a192e524c0f/samples/common/logger.cpp#L30"><code class="language-plaintext highlighter-rouge">logger</code></a> in TensorRT examples.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LogStreamConsumer</span> <span class="n">gLogFatal</span><span class="p">{</span><span class="n">LOG_FATAL</span><span class="p">(</span><span class="n">gLogger</span><span class="p">)};</span>
</code></pre></div></div> <ol> <li> <p><code class="language-plaintext highlighter-rouge">LogStreamConsumer</code> is a class used for handling log messages or streams.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">gLogFatal</code> is an instance of the <code class="language-plaintext highlighter-rouge">LogStreamConsumer</code> class. It is being initialized with the result of LOG_FATAL(<code class="language-plaintext highlighter-rouge">gLogger</code>).</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">LOG_FATAL</code> is a inline function customize the <code class="language-plaintext highlighter-rouge">gLogger</code></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">gLogger</code> is an instance of a Logger class or object.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Initialization</code>: The <a href="https://www.geeksforgeeks.org/uniform-initialization-in-c/"><code class="language-plaintext highlighter-rouge">uniform initialization</code></a> syntax is used: <code class="language-plaintext highlighter-rouge">type var_name{arg1, arg2, ....arg n}</code></p> </li> </ol> <p>The gLogFatal object is being initialized with the result of calling LOG_FATAL with gLogger as an argument. This suggests that LOG_FATAL is constructing a LogStreamConsumer object, possibly based on the severity level of gLogger.</p>]]></content><author><name></name></author><category term="c++"/><summary type="html"><![CDATA[As a newbie to C++, I came across many challenges when working on a project with this versatile language. Learn by doing, these blogs (Learn C++) are the record of practical examples I collected.]]></summary></entry><entry><title type="html">How to Call C++ Class from C</title><link href="https://ggluo.github.io/2023/01/27/how-to-call-cpp-class-from-c.html" rel="alternate" type="text/html" title="How to Call C++ Class from C"/><published>2023-01-27T09:54:00+00:00</published><updated>2023-01-27T09:54:00+00:00</updated><id>https://ggluo.github.io/2023/01/27/how-to-call-cpp-class-from-c</id><content type="html" xml:base="https://ggluo.github.io/2023/01/27/how-to-call-cpp-class-from-c.html"><![CDATA[<p>Calling a C++ class from C can be a bit tricky because C does not support classes and objects like C++. However, you can still interact with C++ code from C by creating a C interface for your C++ class. In this example, we define a C++ class MyClass with a method doSomething(). Then, we create a C wrapper MyClassWrapper that provides functions to create, manipulate, and destroy instances of MyClass. Finally, we can use these functions in a C program to interact with the MyClass object. See <a href="https://github.com/ggluo/Call-cpp-class-from-c">github</a>.</p> <h2 id="define-a-c-class">Define a C++ class</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef MYCLASS_H
#define MYCLASS_H
</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">doSomething</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif // MYCLASS_H
</span></code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"MyClass.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Doing something in MyClass"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="define-a-c-wrapper">Define a C wrapper</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MyClassWrapper.h</span>
<span class="cp">#ifndef MYCLASSWRAPPER_H
#define MYCLASSWRAPPER_H
</span>
<span class="cp">#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
<span class="cp">#endif
</span>
<span class="k">typedef</span> <span class="kt">void</span><span class="o">*</span> <span class="n">MyClassHandle</span><span class="p">;</span>

<span class="n">MyClassHandle</span> <span class="n">createMyClass</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">destroyMyClass</span><span class="p">(</span><span class="n">MyClassHandle</span> <span class="n">obj</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">doSomethingInMyClass</span><span class="p">(</span><span class="n">MyClassHandle</span> <span class="n">obj</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus
</span><span class="p">}</span>
<span class="cp">#endif
</span>
<span class="cp">#endif // MYCLASSWRAPPER_H
</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"MyClassWrapper.h"</span><span class="cp">
#include</span> <span class="cpf">"MyClass.h"</span><span class="cp">
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>

<span class="n">MyClassHandle</span> <span class="n">createMyClass</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">MyClassHandle</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">MyClass</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">destroyMyClass</span><span class="p">(</span><span class="n">MyClassHandle</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">doSomethingInMyClass</span><span class="p">(</span><span class="n">MyClassHandle</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div> <h2 id="use-the-wrapper-in-c">Use the wrapper in C</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"MyClassWrapper.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyClassHandle</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">createMyClass</span><span class="p">();</span>
    <span class="n">doSomethingInMyClass</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">destroyMyClass</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="c++"/><summary type="html"><![CDATA[Calling a C++ class from C can be a bit tricky because C does not support classes and objects like C++. However, you can still interact with C++ code from C by creating a C interface for your C++ class. In this example, we define a C++ class MyClass with a method doSomething(). Then, we create a C wrapper MyClassWrapper that provides functions to create, manipulate, and destroy instances of MyClass. Finally, we can use these functions in a C program to interact with the MyClass object. See github.]]></summary></entry><entry><title type="html">Create a Table of Figures using Latex</title><link href="https://ggluo.github.io/2023/01/04/create-a-table-of-figure-using-latex.html" rel="alternate" type="text/html" title="Create a Table of Figures using Latex"/><published>2023-01-04T18:19:00+00:00</published><updated>2023-01-04T18:19:00+00:00</updated><id>https://ggluo.github.io/2023/01/04/create-a-table-of-figure-using-latex</id><content type="html" xml:base="https://ggluo.github.io/2023/01/04/create-a-table-of-figure-using-latex.html"><![CDATA[<p>Go to this <a href="https://github.com/ggluo/figure-templates">repository</a> and find tex files for the figure below</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 1000px)" srcset="/assets/img/fig-crop-1000.webp"/> <source class="responsive-img-srcset" media="(max-width: 1200px)" srcset="/assets/img/fig-crop-1200.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/fig-crop-1400.webp"/> <img src="/assets/img/fig-crop.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Table of figures" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div>]]></content><author><name></name></author><category term="latex"/><summary type="html"><![CDATA[Go to this repository and find tex files for the figure below]]></summary></entry></feed>